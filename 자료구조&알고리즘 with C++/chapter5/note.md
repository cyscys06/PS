### 그리디 알고리즘
- 매순간 최적의 선택을 하는 알고리즘
- 매순간의 최적의 선택들이 합쳐져 하나의 전역적인 최적 선택을 구성하게 됨

#### 그리디 알고리즘으로 해결 가능한 대표적 두 가지 문제
1. 최단 작업 우선 스케쥴림
2. 분할 가능 배낭 문제

### 최단 작업 우선 스케쥴링
- ex) 하나의 은행 창구에 여러 사람이 줄을 서서 기다리는 경우
- 각자의 업무 시간은 다름
- 각 사람들이 대기하는 시간도 전부 다를 것
-> 대기하는 사람들의 대기시간의 평균을 최대한 줄이는 것이 그리디 알고리즘의 목표
- 해결: 줄을 선 고객들의 대기 시간을 오름차순 정렬하면 전체 고객의 평균 대기시간이 대폭 단축됨
- i번째 고객의 대기시간 = i - 1번째 고객의 대기시간 + i - 1번째 고객의 업무 시간
(내 앞 고객이 기다린 시간 + 내 앞 고객의 업무 시간이 곧 내가 대기하는 시간임)

### P-NP 문제
- P 문제(결정 문제): 
1. 어떤 문제에 대한 답이 yes/no로만 이루어지고
2. 문제 해결 과정에서 한 가지 가능성만 고려 가능하며
3. 문제 해결 시간이 항상 다항식 시간 이내로 수렴하는 경우
ex): 각종 비교식(bool 타입)

- NP 문제(비 결정 문제): 
1. 어떤 문제에 대한 답이 yes/no로만 이루어지지 않고
2. 문제 해결 과정에서 여러 가능성을 고려해야 하며
3. 다항식 시간 내에 문제를 해결할 수 없거나, 
특정 조건을 통해 문제 해결 시간이 다항식 시간 이내인 것을 확인 가능한 경우

### 0-1 배낭 문제(NP 완전 문제)
- 각 물건들(O1, O2, O3, ...)은 무게(W)와 가격(V)을 가짐
- 최대로 버틸 수 있는 무게가 T인 배낭에 물건들을 담아야 함
- 단, 물건들의 무게의 총합이 T 이하여야 하는 동시에, 가격의 총합은 최대야 되어야 함
- 해결: 모든 가능한 조합을 검사하여 무게가 T를 넘지 않고 최대 가격을 가지는 배낭을 찾아야 함
- 모든 가능한 물건 조합(최대 무게 T를 넘지 않는 조합)에서 가장 최대 가격인 조합을 찾기

### 분할 가능 배낭 문제
- 일반 0-1 배낭 문제와 달리, 주어진 물건을 분할 가능하고 각 물건의 일부분만 배낭에 넣을 수 있다고 가정
- ex) 양이 정해진 물건에서 일부분의 양만을 추출하여 배낭에 넣을 수 있음
- 해결: 물건의 일부분만(특정 무게만큼)을 취할 수 있으므로, 각 물건의 단위 무게 당 가격을 계산한 뒤(물건의 전체 가격 / 물건의 전체 무게)
그리디 방식을 따라서 단위 무게 당 가격이 높은 순으로 물건을 선택(내림차순 정렬)
- 만약 마지막 물건 때문에 현재 물건들의 무게 총합이 가방 수용량을 초과하는 경우, 
마지막 물건의 양을 조절해서 물건들의 현재 무게 총합이 가방의 수용량과 같도록 조정 가능

### 그리디 알고리즘 요구 조건
- 최적 부분 구조: 주어진 문제에 대한 최종 최적 솔루션이 부분적 문제들의 최적 솔루션으로 구성되는 경우
- 그리디 선택: 주어진 문제에 대한 지역적 최적 솔루션을 반복적으로 선택하여 최종 최적 솔루션을 구할 수 있는 경우

### 최소 신장 트리 문제
- 정의: 정점(vertex)의 집합 V와 가중치를 갖는 간선(edge)의 집합 E로 구성된 그래프 G = <V, E>가 주어질 때, 모든 정점을 연결하고 연결된 간선의 가중치 합이 최소인 트리 T를 구하시오.
- 예시: 여덟개의 마을이 있고, 모든 마을이 연결되는 도로를 만드는 것이 목표
- 연결된 도로는 사이클을 구성해선 안되고, 연결된 도로의 전체 길이는 최소가 되어야 함(즉, 정답이 되는 트리의 간선의 가중치 총합이 최소가 되어야 함)
- 서로 다른 두 노드끼리는 양방향 이동이 가능
  
#### 해결
1. 그래프 G의 모든 간선을 최소 힙 H에 추가
2. H에서 간선 e를 하나 꺼냄. 가중치 총합을 최소로 해야 하고, 그리디 알고리즘을 사용하므로 e는 모든 간선 중 가중치 값이 최소인 간선임
3. e의 양 끝 정점이 이미 T에 있을 경우, e로 인해 사이클이 발생할 수 있으므로 e를 삭제 후 다시 2번 과정을 반복
4. e의 양 끝 정점이 T에 없는 경우, e를 T에 추가하고 2번 과정을 반복

### 디스조인트 셋
- 최소 신장 트리 알고리즘을 해결하기 위해 사용하는 자료구조
- 트리 형태의 원소들로 구성, 각 원소는 ID와 랭크, 부모에 대한 포인터 변수를 가짐(새로 추가한 원소의 랭크는 0이며, 부모에 대한 포인터 변수는 자신을 가리킴)
- 앞으로 매개변수 x, y 등은 노드의 ID(즉, 노드 자체)를 의미함
  
#### 내부 유틸 함수
##### make_set(x)
- 매개변수 x를 ID로 갖는 원소를 디스조인트 셋에 추가하는 함수
- 새로 추가된 원소 랭크는 0이고, 부모 포인터 변수는 자기 자신을 가리킴

##### find(x)
- 원소 x(ID?)에서 시작하고 부모 포인터를 통해 이동하면서 트리의 루트 노드의 주소를 반환함
- 루트 원소가 부모를 가리키는 포인터는 자기 자신이므로, 루트 노드에서 find 함수를 사용하면 자기 자신을 반환함

##### union(x, y)
1. x, y 노드가 속한 트리의 루트 노드를 각각 찾음
2. 만약 둘의 루트 노드가 같으면 두 노드는 같은 트리에 속한 것이므로 아무 작업도 하지 않음.
만약 둘의 루트 노드가 다르면 서로 다른 두 루트 노드 중 높은 랭크의 루트 노드를 낮은 랭크의 루트 노드의 부모 노드로 설정함.


### 그래프 컬러링
- 정의: 주어진 그래프 G에서 서로 인접한 정점끼리 같은 색을 가지지 않도록 모든 정점에 색상을 지정해야 하는 문제
- 예시: 택시 예약, 스도쿠, 시험 시간표 작성 등
- NP-완전 문제
  
### 스도쿠 문제
- 해결: 각각의 셀(한칸짜리 상자)을 그래프 정점으로 표현
- 같은 행, 같은 열, 3*3 블록 안에 있는 모든 정점(셀)끼리 간선을 연결
- 위 과정으로 생성된 그래프 G에 대해 그래프 컬러링 알고리즘을 적용하면 해결 가능

