### 시간복잡도
- 알고리즘의 연산 시간을 수식을 통해 표현한 것
- 데이터 크기에 따라 연산 시간이 달라짐
- 보통 최악을 기준으로 상정함

### 자료구조의 분류
- 연속된 자료구조, 연결된 자료구조로 구성
#### 연속된 자료구조
- 연속된 자료구조는 하나의 큰 메모리 공간에 데이터들을 저장 ex) 배열
- 배열에는 모두 동일한 데이터 타입의 데이터만 들어갈 수 있음
- 배열의 전체 크기 = 배열에 들어갈 데이터 타입의 크기 * 데이터 개수
- 배열의 이름은 배열의 시작 주소이며, 배열의 모든 인덱스는 배열의 시작 주소를 기준으로 
(해당 데이터가 든 인덱스 번호) * 데이터 타입만큼의 값을 더하여 한번에 접근할 수 있음
- 즉, 배열의 n번째 인덱스에 접근하는 시간은 O(1)
#### 연결된 자료구조
- 노드라고 불리는 데이터 청크에 데이터를 저장
- 각 노드는 실제 의미가 있는 데이터인 data, 다음 노드를 가리키는 포인터인 next가 있음
- 여러 노드가 서로 연결된 형태를 연결 리스트라고 부름
- 연결 리스트에서 i번째 노드에 접근하려면 총 i번만큼 노드들을 이동해야 함
- 즉, 연결 리스트의 n번째 노드에 접근하는 시간은 O(n)

#### 연결 리스트에서 노드를 삭제하거나 추가하는 방법
노드 삭제(i번째 노드를 삭제하는 경우)
1. i - 1번째 노드의 next 포인터가 i + 1번째 노드의 주소를 가리키도록 변경
2. i번째 노드의 next 포인터가 null을 가리키도록 변경
3. i번째 노드를 delete

노드 추가(i번째 노드를 추가하는 경우)
1. i번째 노드를 생성
2. i번째 노드의 next 포인터가 i + 1번째 노드의 주소를 가리키도록 변경
3. i - 1번째 노드의 next 포인터가 i번째 노드의 주소를 가리키도록 변경

### 캐시 지역성
- 연속된 자료구조에서 특정 인덱스에 접근할 때, 그 인덱스에 인접한 다른 인덱스의 값도 캐시로 가져오는 특성
- 다시 주변 인덱스에 접근할 때 해당 원소를 미리 저장해놓은 캐시에서 가져오게 됨. 이 작업의 속도는 매우 빠름
- 이러한 특성이 시간복잡도에 큰 영향을 주는 것은 아니나(애초에 시간복잡도는 최악을 기준으로 나타낸 것임), 캐시 지역성을 통해 배열같은 연속된 자료구조에서 데이터에 빠르게 접근할 수 있음
- 단, 캐시 지역성이 적용되는 종류는 연속된 자료구조 뿐이며, 연결된 자료구조는 캐시 지역성이 없음

#### begin(), end()
- 각각 자료구조의 첫 원소의 주소, 마지막 원소의 다음을 가리키는 함수들임
- 반복 가능한 자료구조에서 사용 가능(배열, 벡터, 맵, 세트, 리스트 등)


### 벡터
- 용량(capacity)이라는 개념 있음
- 용량: 벡터에서 벡터의 크기를 유동적으로 조절할 수 있게 해주는 데이터
- 용량은 항상 벡터의 크기 이상의 값을 가짐
- 벡터에 원소를 추가할 때, 벡터가 꽉 찼다면(즉 벡터 안에 있는 원소의 개수가 벡터의 크기만큼이라면), 
벡터의 용량을 재할당해서 벡터의 크기를 늘릴 수 있게 해줌
#### 벡터 원소 추가
- push_back(): 벡터의 맨 마지막 자리에 원소 추가.
내부 코드: 만약 새 원소를 추가할 공간이 있으면 마지막으로 추가된 원소의 다음 위치에 새 원소를 추가
만약 새 원소를 추가할 공간이 없으면 벡터 용량을 2배로 재할당하고(이때 이 2배인 용량은 새로운 메모리임)
데이터들을 새로운 메모리로 옮기고
포인터 주소도 새로운 메모리의 주소로 재할당하고
새로운 메모리 안에서 원소를 추가하고 벡터 크기를 1 증가
-> 새 원소 추가할때는 O(1), 용량 재할당할때는 O(n) 걸림(모든 n개 원소를 복사해야 하므로),
평균적으로 O(1)만큼 걸림(빠름)
- insert(): 삽입할 위치에 대한 매개변수를 추가로 받아서 원하는 위치에 원소를 추가 가능
insert()는 중간에 원소를 삽입할때, 중간에 원소를 넣고 그 뒤 원소들을 모두 한자리씩 밀어야 하므로 총 O(n)의 시간이 걸림
-> insert()는 평균적으로 O(n)만큼 소요
- push_back(), insert() 함수 단점: 이미 생성된 객체를 받아 그 객체를 벡터 안에 추가하는 방식
-> 생성된 객체를 받은다음, 그 객체를 복사한 임시 객체를 하나 더 만들어서 벡터 안에 넣음
-> 이는 똑같은 내용의 객체를 하나 더 만드는 꼴이어서 불필요함
- 해결: emplace, emplace_back을 이용한다.
-> 두 함수는 생성된 객체를 전달인자로 받지 않고, 벡터에 저장될 실제 값의 형태로 매개변수를 받음
-> 전달인자를 통해 함수 내부에서 객체를 생성하고, 생성한 객체를 벡터에 바로 추가함
-> 불필요한 과정이 생략되어 효율이 높아짐

#### 벡터 원소 삭제
- pop_back, erase 함수 있음
- pop_back: 가장 끝에 있는 원소를 제거 후, 벡터 크기를 1 감소시킴
-> 맨 끝에 있는 원소만 삭제하므로 O(1) 만큼 시간 소요
- erase: 특정 위치에 있는 원소를 제거하거나, 특정 범위 안에 있는 모든 원소들을 제거할 수 있음
-> 특정 위치 원소를 삭제한 후, 그 뒤에 있는 원소들을 모두 앞으로 이동시켜야 해서
총 O(n) 만큼 시간이 소요됨

#### 기타 유틸 함수
clear: 벡터의 모든 원소 삭제
reserve: 벡터의 용량을 변경(벡터 크기 변경 X). 
매개변수가 용량보다 크면 벡터 용량을 매개변수로 재할당, 매개변수가 용량보다 작으면 변화 X
shrink_to_fit: 벡터 용량 - 벡터 크기 만큼의 크기 삭제. 벡터 용량이 벡터 크기와 같아짐

#### 템플릿 함수를 통한 다양한 데이터 타입 지원
- 아직은 필요성 못느끼겠음

### 포워드 리스트
- 자료구조에서 중간 위치에 데이터를 추가하는 방식의 단점(시간이 오래걸리는 것)을 보완하기 위해 만든,
연결 리스트의 래퍼 클래스
- 일반 연결 리스트와 달리 리스트의 맨 뒤로 이동하는것은 불가능
- 그대신 연산 속도가 빠름
#### 포워드 리스트 원소 추가
- 포워드 리스트에서 원소를 삽입하는 함수들은 모두 데이터를 리스트의 맨 앞에 삽입하므로 시간복잡도가 항상 O(1)임
- 리스트의 마지막 원소에 접근하는 함수는 없음(push_back같은건 없음)
- 향상 버전인 emplace_front, emplace_after함수 있음
#### 포워드 리스트 원소 삭제
- pop_front, erase_after 함수 있음
- remove, remove_if: 포워드 리스트의 노드 data를 삭제할 수 있는 또다른 함수들
-> 실제로 컨테이너 안에 든 값을 삭제하는게 아님. 삭제할 값들만 컨테이너의 맨 뒤로 올리고, 나머지 값들에 대한 이터레이터를 반환함.
-> 값을 실제로 삭제하려면 컨테이너들 고유의 삭제 함수를 호출해야 함
- remove: 매개변수로 받은 값과 일치하는 데이터를 삭제
-> 단순히 등호 연산자(==)로 비교하므로, 객체에는 사용이 불가(에러)
- remove_if: 매개변수에 bool형 값을 반환하는 조건자 함수가 통째로 들어감
- (조건자 함수: 보통의 비교 연산자와 달리, 별도의 비교 기준을 가진 함수)
-> 조건자 함수가 true를 반환하는 모든 값을 리스트에서 삭제함
-> 조건자 함수에서 객체끼리 비교할 수 있게 식을 짜면, remove_if로 객체에도 사용이 가능하게 만들 수도 있음
- remove, remove_if 두 함수 모두 전체 컨테이너를 순회하므로 O(n) 소요

#### 포워드 리스트 원소 정렬
- 포워드 리스트의 원소들은 연결된 자료구조 형태여서 직접 접근이 불가능함
- 따라서 별도의 비교자 std::less<value_type>을 만들어서 노드의 data끼리 대소 비교를 할 수 있게 함
- 정렬하는 로직은 4장에서
#### 기타 유틸 함수
- reverse: 원소 순서를 역순으로 변경(시간 복잡도 O(n))
- unique: 중복되는 원소들은 컨테이너의 맨 뒤로 빼는 함수
-> 원소를 직접 삭제하는 함수가 아님
-> 또한 서로 인접하는 원소끼리만 중복을 체크하므로, unique함수를 사용하기 전에 원소들을 한번 정렬해줘야 함
-> 시간복잡도 O(n) (전체 컨테이너를 한번 순회하므로)
-> remove_if처럼 등호연산자로 비교할수도, 아니면 사용자가 정의한 조건자 함수를 적용할 수도 있음

### 반복자
- 컨테이너 내부의 값에 접근 가능한 객체
- 컨테이너 종류에 따라 여러가지 반복자가 사용됨
#### 임의 접근 반복자
- 벡터 등에서 사용하는 반복자
- 컨테이너 내부의 모든 곳에 임의로 접근 가능하며, 시간복잡도 또한 O(1)
#### 순방향 반복자
- 포워드 리스트 등에서 사용하는 반복자
- 진행 방향(보통 앞에서 뒤로)으로만 움직일 수 있는 반복자
#### 반복자 관련 함수
- advance: 반복자와 거리 값을 인자로 받아서, 반복자 값을 거리 값만큼 증가시키는 함수
- next, prev: 마찬가지로 반복자와 거리 값을 인자로 받아 반복자 값을 거리 값만큼 증가시키는 함수
- 만약 순방향 반복자에서 반복자 값을 감소시키려 하면(음수를 더하면) 에러 뜸(앞에서 뒤로만 움직일 수 있으므로)
- 또한 순방향 반복자에 +연산자 적용 안됨(ex: it += 2, 단 증가연산자는 가능)
-> 함수 내부에서도 전달받은 값만큼 반복자에 증가연산자를 사용해 1씩 더함(이를 전달받은 값만큼 반복하는것)
  
#### 상수 시간
- 배열 또는 단순 메모리에 접근하는 데 걸리는 시간을 기준으로 한 시간
- 즉 O(1)
#### 선형 시간
- O(n)처럼 단순한 상수만큼의 시간이 걸리는게 아닌, 연산 시간이 수식 형태로 표현되는 시간


### 이중 연결 리스트
- 순방향으로만 이동할 수 있었던 기존의 포워드 리스트와 달리 역방향으로도 이동할 수 있는 리스트
- 이전 노드의 주소를 가리키는 prev 필드를 추가로 가짐
- 단 포워드 리스트에 비해 메모리를 좀 더 사용함

#### 이중 연결 리스트 원소 추가
1. 새로운 노드 추가
2. 새로운 노드의 prev가 이전 노드를 가리키도록 변경
3. 이전 노드의 next가 새로운 노드를 가리키도록 변경
4. 새로운 노드의 next가 이후 노드를 가리키도록 변경
5. 이후 노드의 prev가 새로운 노드를 가리키도록 변경

#### 양방향 반복자
- 순방향 반복자, 임의 접근 반복자의 중간 정도에 위치한 반복자라고 보면 됨
- 순방향 반복자와 달리 양방향으로 모두 이동 가능함
- 임의 접근 반복자처럼 특정 위치로 한번에 이동하는 것은 불가능함
-> 선형 시간복잡도 O(n)

### 반복자 무효화
- 특정 경우에 기존 컨테이너에서 사용하던 반복자가 무효화되는(더이상 쓸모없어지는) 경우가 있음
- ex) 벡터에서 새로운 메모리를 할당하여 그 메모리에 값을 재할당하는 경우,
벡터에서 중간 위치에 원소를 삽입할 때 뒤에 있는 원소를 한자리씩 뒤로 이동해야 하는 경우,
연결 리스트에서 한 노드를 삭제했을 경우 등

### 덱
- 양방향 큐의 약자
- 양방향으로 확장 가능하고, 모든 원소에 대해 임의 접근 반복자를 가짐
- 단일 메모리 청크에 데이터를 저장하는 벡터와 달리, 
크기가 같은 여러 개의 데이터 청크를 사용해서 데이터를 저장
- 이를 통해 특정 데이터가 어느 청크의 어느 위치에 저장돼있는지 알 수 있음
- 모든 청크의 주소를 연속적인 자료구조에 저장해놓고 사용하면 O(1)의 시간 복잡도를 가질 수 있음
-> 즉, 여러 메모리 공간을 만들어 데이터를 저장하고, 그 메모리 공간의 주소들을 연속된 자료구조에 한데 모아놓는 것
-> 주소를 연속적인 자료구조에 저장하는 부분이 벡터, 배열과 유사함


### 컨테이너 어댑터
- 스택, 큐 같은 자료구조들은 기존 자료구조를 감싼 래퍼 클래스임
- 기존 자료구조에 추가 기능을 넣거나, 별도의 구분을 위해 만들었음

### 스택
- 후입선출(마지막에 들어온게 먼저 나감)
- 덱을 기반으로 만든 자료구조(벡터 기반 아님)
- 원소를 추가 및 삭제하는 시간복잡도가 모두 O(1)임

### 큐
- 선입선출(먼저 들어온게 먼저 나감)
- 큐에서의 push함수(원소 추가 함수)는 벡터, 스택에서의 push_back과 같음.
- 하지만 pop함수는 맨 뒤에 있는 원소가 아닌 맨 앞에 있는 원소를 제거함(선입선출 구조이므로)

### 우선순위 큐
- 힙이라는 저장소에 데이터를 저장하는 컨테이너
- 큐 안에 있는 원소들에 우선순위를 매긴 형태(보통 대소비교로 우선순위를 매김)
- 최소/최대 원소에 접근하는 시간은 O(1)로, 빠른 접근이 가능함
-> 우선순위를 최대/최소 중 어떤 것으로 할지 정할 수 있음. 하지만 최대/최소 원소에 동시에 빠르게 접근하는 것은 불가능
- 원소 추가 시간은 O(logn)임
- 히피파이: 현재 우선순위 큐에 들어있는 원소들을 우선순위 기준에 따라 자동 정렬하는 알고리즘
-> 새로운 원소 삽입 시마다 자동 호출됨
-> 우선순위 큐 초기화 시에는 O(n)인 별도의 힙 생성 알고리즘 사용